%*****IEEE CEC 2022 Competition on Dynamic Optimization Problems Generated by Generalized Moving Peaks Benchmark******
%Author: Danial Yazdani
%Last Edited: December 06, 2021
%
% ------------
% Reference:
% ------------
%  
%  D. Yazdani et al.,
%            "Benchmarking Continuous Dynamic Optimization: Survey and Generalized Test Suite,"
%            IEEE Transactions on Cybernetics (2020).
% 
%  D. Yazdani et al.,
%            "Generalized Moving Peaks Benchmark," arXiv:2106.06174, (2021). 
% 
%  T. Blackwell and J. Branke,
%            "Multiswarms, exclusion, and anti-convergence in dynamic environments"
%            IEEE Transactions on Evolutionary Computation (2006).
% ------------
% Notification:
% ------------
% This code solves Generalized Moving Peaks Benchmark (GMPB) by mQSO.
% It is assumed that the environmental changes are VISIBLE, therefore,
% mQSO is informed about changes (i.e., mQSO does not need to detect
% environmental changes). Also note that mQSO does not access to a prior knowledge
% about the shift severity value. The shift severity is learned in this code.
%
% 
% -------
% Inputs:
% -------
%
%    The Participants can set peak number, change frequency, dimension, 
%    and shift severity in lines 59-62 of "main.m" according to the
%    competition instractions available in the following link:
%                                
%                 https://www.danialyazdani.com/CEC-2022
% 
%
% ------------
% Output:
% ------------
% 
% Offline error
% 
% --------
% License:
% --------
% This program is to be used under the terms of the GNU General Public License
% (http://www.gnu.org/copyleft/gpl.html).
% Author: Danial Yazdani
% e-mail: danial.yazdani AT gmail dot com
%         danial.yazdani AT yahoo dot com
% Copyright notice: (c) 2021 Danial Yazdani
%*********************************************************************************************************************
DFileName = 'main.log';
LogPathName = 'test';

diary off;
LogPath = fullfile('.', 'logs', LogPathName);
if ~exist(LogPath, 'dir')
    mkdir(LogPath)
end
DFile = fullfile(LogPath, DFileName);
if exist(DFile, 'file') ; delete(DFile); end
diary(DFile);
diary on;

ParallelProblem = [1:4 6:14];
IndependentProblem = [5];
%% Input variables
%********Benchmark parameters and Run number***
PeakNumbers = [5,	10,	25,	50,	100,	10,	10,	10,	10,	10,	10,	10,  1,  10];
ChangeFrequencys = [5000,	5000,	5000,	5000,	5000,	2500,	1000,	500,	5000,	5000,	5000,	5000,  5000,  5000];
Dimensions = [5,	5,	5,	5,	5,	5,	5,	5,	10,	20,	5,	5,  5,  2];
ShiftSeveritys = [1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	2,	5,   1,  1];

disp(['Start time: ', datestr(now)]);

parfor index = 1:length(ParallelProblem)
    ProblemNum = ParallelProblem(index);
    ProblemRun(ProblemNum, PeakNumbers(ProblemNum), ChangeFrequencys(ProblemNum), Dimensions(ProblemNum), ShiftSeveritys(ProblemNum), 100, 31, false, LogPath);
end

for index = 1:length(IndependentProblem)
    ProblemNum = IndependentProblem(index);
    ProblemRun(ProblemNum, PeakNumbers(ProblemNum), ChangeFrequencys(ProblemNum), Dimensions(ProblemNum), ShiftSeveritys(ProblemNum), 100, 31, true, LogPath);
end

function ProblemRun(ProblemNum, PeakNumber, ChangeFrequency, Dimension, ShiftSeverity, EnvironmentNumber, RunNumber, IfParallel, LogPath)
    disp(['PROBLEM NUMBER: ', num2str(ProblemNum), ' Runnumber: ', num2str(RunNumber)]);
    OuputFile = fullfile(LogPath, sprintf('F%d.dat', ProblemNum));
    if exist(OuputFile, "file")
        OfflineError = ReadFile(OuputFile);
        if size(OfflineError, 1) ~= RunNumber
            OfflineError = NaN(1, RunNumber);
        end
        disp(size(OfflineError, 1));
    else
        OfflineError = NaN(1, RunNumber);
    end
    function UpdateOfflineError(x)
        OfflineError(x(1)) = x(2);
        WriteFile(OuputFile, OfflineError);
        disp(['Offline Error Updated (Run: ', num2str(x(1)), ').']);
    end
    if IfParallel
        D = parallel.pool.DataQueue;
        D.afterEach(@(x) UpdateOfflineError(x));
        W = WorkerObjWrapper(OfflineError);
        parfor RunCounter=1 : RunNumber
            ErrorArray = W.Value;
            if ~isnan(ErrorArray(RunCounter))
                disp(['Problem: ', num2str(ProblemNum), ' Run: ', num2str(RunCounter), sprintf('\t'), 'already finished.']);
                continue;
            end
            CurrentError = IndependentRun(ProblemNum, RunCounter, PeakNumber, ChangeFrequency, Dimension, ShiftSeverity, EnvironmentNumber);
            send(D, [RunCounter, mean(CurrentError)]);
        end
    else
        for RunCounter=1 : RunNumber
            if ~isnan(OfflineError(RunCounter))
                disp(['Problem: ', num2str(ProblemNum), ' Run: ', num2str(RunCounter), sprintf('\t'), 'already finished.']);
                continue;
            end
            CurrentError = IndependentRun(ProblemNum, RunCounter, PeakNumber, ChangeFrequency, Dimension, ShiftSeverity, EnvironmentNumber);
            OfflineError(RunCounter) = mean(CurrentError);
            WriteFile(OuputFile, OfflineError);
        end
    end
    E_o = [mean(OfflineError),median(OfflineError),std(OfflineError)/sqrt(RunNumber)];
    close;clc;
    disp(['Offline error ==> ', ' Mean = ', num2str(E_o(1)), ', Median = ', num2str(E_o(2)), ', Standard Error = ', num2str(E_o(3))]);
    WriteFile(OuputFile, OfflineError);
end

function [CurrentError] = IndependentRun(ProblemNum, RunCounter, PeakNumber, ChangeFrequency, Dimension, ShiftSeverity, EnvironmentNumber)
    rng(RunCounter);%This random seed setting is used to initialize the Problem-This must be identical for all peer algorithms to have a fair comparison.
    Problem = BenchmarkGenerator(PeakNumber, ChangeFrequency, Dimension, ShiftSeverity, EnvironmentNumber);
    rng(RunCounter);%Set a random seed for the optimizer based on the system clock
    %% Initialiing Optimizer
    clear Optimizer;
    Optimizer.Dimension = Problem.Dimension;
    Optimizer.PopulationSize = 5;
    Optimizer.MaxCoordinate   = Problem.MaxCoordinate;
    Optimizer.MinCoordinate = Problem.MinCoordinate;
    Optimizer.DiversityPlus = 1;
    Optimizer.x = 0.729843788;
    Optimizer.c1 = 2.05;
    Optimizer.c2 = 2.05;
    Optimizer.ShiftSeverity = 1;
    Optimizer.QuantumRadius = Optimizer.ShiftSeverity;
    Optimizer.QuantumNumber = 5;
    Optimizer.SwarmNumber = 10;
    Optimizer.ExclusionLimit = 0.5 * ((Optimizer.MaxCoordinate-Optimizer.MinCoordinate) / ((Optimizer.SwarmNumber) ^ (1 / Optimizer.Dimension)));
    Optimizer.ConvergenceLimit = Optimizer.ExclusionLimit;
    for ii=1 : Optimizer.SwarmNumber
        [Optimizer.pop(ii),Problem] = InitializingOptimizer(Optimizer.Dimension,Optimizer.MinCoordinate,Optimizer.MaxCoordinate,Optimizer.PopulationSize,Problem);
    end
    %% main loop
    tic;
    while 1
        [Optimizer,Problem] = Optimization(Optimizer,Problem);
        if Problem.RecentChange == 1%When an environmental change has happened
            Problem.RecentChange = 0;
            [Optimizer,Problem] = Reaction(Optimizer,Problem);
            clc; disp(['Run number: ',num2str(RunCounter),'   Environment number: ',num2str(Problem.Environmentcounter), ' counter:', num2str(RunCounter), ' PROBLEM NUMBER: ', num2str(ProblemNum)]);
            toc;
            tic;
        end
        if Problem.FE >= Problem.MaxEvals%When termination criteria has been met
            break;
        end
    end
    CurrentError = Problem.CurrentError;
end

function WriteFile(OuputFile, OfflineError)
    f = fopen(OuputFile, 'w');
    fprintf(f, '%f ', OfflineError);
    fclose(f);
end

function [OfflineError] = ReadFile(OuputFile)
    OfflineError = str2double(split(fileread(OuputFile)));
    OfflineError = OfflineError(1:end-1);
end